

 -0 Typical Session State size
-------------------------------
  > 3 to 200 KB
  > 


 -0 high availability
----------------------
  > requires a stateful-failover architecture

 -0 Cost of Replicating Sessions
------------------------------------
  > if each session is mirrored across entire pool of app servers
  > each server must use memory to store that session
  > each mirrored session is going to consume resources on their respective app server
  > however, app server has a limited amount of memory
  > aliter - memory is required for various other purposes too
  > this will reduce the memory for other important tasks
  > hence, speed required to execute app logic will reduce
  > Hence, more scalability, i.e. highly failover requirement, will push for more servers
  > with each server addition, session memory consumption per server increases & 
  > in turn more slower performance
  > In short period of time, system wont be scalable further

 -0 High Available Solution
---------------------------------
  > shared database in application along with load balancers
  > server affinity i.e. sticky session based load balancers
   >> however, above requires an assumption on session
   >> can be any data in the HTTP headers
   >> or any data in HTTP payload
   >> but using the automatically generated session ids tend to be the most common implementation 

 -0 What is the session state info provided to load balaancer ?
----------------------------------------------------------------


-0 Performance Aspects
---------------------------
  > should perform in large distributed systems
  > 

 -0 Reliability Aspects
---------------------------
  > avoid single point of failure
  > 

 -0 Synchronization Aspects
------------------------------
  > support synchronous as well as sync
  > support events
  > support heartbeats
  > 


 -0 Monitoring Aspects
-------------------------
  > if Read request registers a watch that watch is tracked locally @ the server
  > 

 -0 In-Memory data
---------------------------
  > achive high throughput & low latency
  > by avoiding disk I/O
  > downside - size of database is limited by memory

 -0 Clustered In-memory data
-----------------------------
  > in a clustered environ, the db could be partitioned
  > then replicated into segments
  > & stored in main memory of several nodes
  > 

 -0 Centralized Server
--------------------------
  > clients connect to a Single server
  > if client to server connection breaks, client will connect to a different server
  > session will get restablished in the new server

 -0 Request Types
---------------------------------------
  > support multiple request types
  > Read, Write, Sync
  > Read requests are processed locally to which the client is connected
  > Write requests are forwarded to other servers & go through a consensus before a response is generated
  > Sync requests are forwarded to other servers but do not go through consesus
  > throughput of read requests scales with no of servers
  > throughput of write requests decrease with no of servers
  > All updates are ordered

 -0 Centralized Metadata Management
----------------------------------------
  > store coordinate data
  > store status info
  > location info

 -0 Replication
----------------------
  > replicate on create
  > replicate on faliure




References
----------------
1/ https://devcentral.f5.com/blogs/us/sessions-sessions-everywhere
2/ 

