 -0 Suggested Solutions
------------------------
  > http://www.warski.org/blog/2012/06/implementing-message-replication-in-elasticmq-with-jgroups/
  > http://www.rabbitmq.com/blog/2010/09/22/broker-vs-brokerless/
  > http://puniverse.github.com/galaxy/about.html

 -0 Questions
--------------------
  > What is the session state info (preferably size of session) provided to load balaancer w.r.t MAG nodes ?
  > What is the session state info (preferably size) mirrored across nodes via JGroups ?
  > How is JGroups session replication done ?   
   >> Is there any Message Queue layer for session replication/mirroring ?
  > When is JGroups session replication done ? 
   >> At session create, update & delete or only during failover ?
  > Which usecases are dependent on JGroups ?
   >> JGroups provides clustering, leader election, 
   >> state transfer (to bootstrap a new node with a current picture of the task tree).
   >> Do we need all of these features provided by JGroups ?
   

 -0 ZooKeeper
----------------------
  > highly available, scalable, distributed configuration, consensus, group membership, leader election
  > a system for coordinating distributed processes
  > In order to be useful Zookeeper must be highly reliable & available as systems will depend on former .. 


 -0 Zookeeper Recipes
-------------------------
  > Use Zk to implement below:
  >> barriers
  >> locks
  >> queues
  >> counter
  >> 2 phase commit
  >> leader election

 -0 Zookeeper - a low level stuff
--------------------------------------
  > is a low level stuff
  > need some libraries i.e. wrapper on top of Zk to prove Zk
  > Netflix's Curator is one such

 -0 Zookeeper - Recipe - Distributed bag
-----------------------------------------
  > allows processes to share a collection
  > Any participant can post or remove data alerting all others
  > useful for cases where processes need to share configuration determined @ runtime
  > used as a part of Role Match
  > provides event based subscriptions making implementation simpler
  > 





 -0 Zookeeper Service
------------------------
  > all servers store a copy of the data in memory
  > leader is elected @ startup
  > all updates go through the leader
  > responses are sent when a majority of servers have persisted the change

 -0 ZeroMQ
--------------------
  > push pull
  > req-rep
  > pub-sub (multicast, broadcast)
  > workload distribution

 -0 Kafka/Redis
-----------------
  > push-pull with persistence
  > workload buffering & distribution





 -0 Typical Session State size
-------------------------------
  > 3 to 200 KB
  > 


 -0 high availability
----------------------
  > requires a stateful-failover architecture

 -0 Cost of Replicating Sessions
------------------------------------
  > if each session is mirrored across entire pool of app servers
  > each server must use memory to store that session
  > each mirrored session is going to consume resources on their respective app server
  > however, app server has a limited amount of memory
  > aliter - memory is required for various other purposes too
  > this will reduce the memory for other important tasks
  > hence, speed required to execute app logic will reduce
  > Hence, more scalability, i.e. highly failover requirement, will push for more servers
  > with each server addition, session memory consumption per server increases & 
  > in turn more slower performance
  > In short period of time, system wont be scalable further

 -0 High Available Solution
---------------------------------
  > shared database in application along with load balancers
  > server affinity i.e. sticky session based load balancers
   >> however, above requires an assumption on session
   >> can be any data in the HTTP headers
   >> or any data in HTTP payload
   >> but using the automatically generated session ids tend to be the most common implementation 


-0 Performance Aspects
---------------------------
  > should perform in large distributed systems
  > 

 -0 Reliability Aspects
---------------------------
  > avoid single point of failure
  > 

 -0 Synchronization Aspects
------------------------------
  > support synchronous as well as sync
  > support events
  > support heartbeats
  > 


 -0 Monitoring Aspects
-------------------------
  > if Read request registers a watch that watch is tracked locally @ the server
  > 

 -0 In-Memory data
---------------------------
  > achive high throughput & low latency
  > by avoiding disk I/O
  > downside - size of database is limited by memory

 -0 Clustered In-memory data
-----------------------------
  > in a clustered environ, the db could be partitioned
  > then replicated into segments
  > & stored in main memory of several nodes
  > 

 -0 Centralized Server
--------------------------
  > clients connect to a Single server
  > if client to server connection breaks, client will connect to a different server
  > session will get restablished in the new server

 -0 Request Types
---------------------------------------
  > support multiple request types
  > Read, Write, Sync
  > Read requests are processed locally to which the client is connected
  > Write requests are forwarded to other servers & go through a consensus before a response is generated
  > Sync requests are forwarded to other servers but do not go through consesus
  > throughput of read requests scales with no of servers
  > throughput of write requests decrease with no of servers
  > All updates are ordered

 -0 Centralized Metadata Management
----------------------------------------
  > store coordinate data
  > store status info
  > location info

 -0 Replication
----------------------
  > replicate on create
  > replicate on faliure




References
----------------
1/ https://devcentral.f5.com/blogs/us/sessions-sessions-everywhere
2/ http://blog.cloudera.com/blog/2009/05/building-a-distributed-concurrent-queue-with-apache-zookeeper/

