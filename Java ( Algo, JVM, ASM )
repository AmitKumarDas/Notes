 To Read & references
-------------
  > http://java.dzone.com/articles/detecting-java-threads
  > http://jonasboner.com/publications/AOSD_2007_Final.pdf
  > http://jonasboner.com/publications/JVM_AOP_AOSD2006.pdf
  > cglib vs java agent ?
  > Annotation on types - JSR 308
  > Meta Object Protocol - JDK 9
  > 
 


 Threading & Non-deterministic Behavior
-------------------------------------------
  > Why ?
  > else Threads will accidentally share data & override each other data

 Thread + ReEntrantLock
---------------------------
  > lock blocks & wait till lock is ready
  > use of try finally to unlock
  > no synchronized block

 Thread + CountDownLatch
---------------------------
  > wait till countdown latch goes to 0
  > other thread need to call countDown()

 Thread + Semaphore
-----------------------
  > Can be binary if 1 permit
  > wait till the semaphore is available
  > same thread or other thread can release the semaphore .. no owner
  > no synchronized block


 When Annotations
---------------------
  > solving the solution via tuples
  > solving the solution via Map & if else condition
  > use annotation to do filtering & invoke the method if match found
 
 How Annotations
------------------
  > need to use reflection to capture the methods/fields
  > try to restrict the annotation to return String
  > may be try with exotic lambdas & annotations later
  
 How Annotation -- Example
-------------------------------
   @Retention(RetentionPolicy.RUNTIME)
   @Target(ElementType.METHOD)
   public @interface Match {
       String value();
   }
   
   ...
   final Match match = method.getAnnotation(Match.class);
               if (match != null) {
                ....

 


 Byteman --> Run Faster
-----------------------
  > tell Byteman to translate rule into bytecode
  > system property - org.jboss.byteman.compile.to.bytecode


 Byteman - JRE or JDK
----------
  > anyone
  > JDK when dynamic loading required

 Byteman - Run
-----------------
  > java -javaagent:${BYTEMAN_HOME}/lib/byteman.jar=script:appmain.btm org.my.AppMain foo bar baz
  > start executing Byteman scripts during JVM startup

 Byteman --> $0, $1, ...
--------------------------
  > $0 --> refers to the target i.e. join point
  > $1, $2 --> arguments of the point cuts of the target

 Byteman & Bootstrap class loader
--------------------------------
  > Class which gets loaded by the bootstrap classloader
  > Needs extra options for aspecting via Byteman
  > i.e. use of boot:...

 Byteman & Aspecting java.lang.*
-------------------------------------
  > Need to define system property for this
  > org.jboss.byteman.transform.all

 Byteman --> Simplified
--------------------------
  > Look running the bmjava.sh






 Groovy --> AOP 
--------------------
  > ProxyMetaClass - change behavior of already loaded classes
  > GroovyInterceptable - implement this interface - override invokeMethod()


 Customer Site Debugging & Analysis
--------------------------------------
  > http://youdebug.kenai.com/
  > Analyze w.r.t Byteman


  Groovy --> AST Transformations
-----------------------
  > hook into the compilation process to transform the code
  > add new methods, imports etc 
  > Test methods etc too can be added during compilation



 Fault Injection
----------------------
  > http://youdebug.kenai.com/
  > http://theholyjava.wordpress.com/2012/02/25/cool-tools-fault-injection-into-unit-tests-with-jboss-byteman-easier-testing-of-error-handling/
  > https://community.jboss.org/wiki/FaultInjectionTestingWithByteman


 Java AOP --> Traditional
----------------------------
  > either use a framework to modify byte-code of our own classes
  > or
  > create a proxy for our own classes (JDK Dynamic Proxies or CGLib)

 Groovy AOP --> MOP
---------------------
  > Metaobject-Protocol 
  > can intercept every single call to our objects without 
  > > the need for a proxy or byte-code manipulation



 JVM --> Clustering
---------------------
  > hub-and-spoke
  > 1 central & various clients
  > central - tracks which node holds the lock
  > central - tracks which nodes reference which part of shared state
  > central - tracks which objects have not been used for a specific period & can be paged out
  > central - serves as a dedicated state database
  > central - itself is culsterable via a SAN-based failover mechanism
  > hub-and-spoke - no need to multicast like peer-to-peer
  
 JVM --> Clustering --> state sharing & thread coordination
-------------------------------------------------------------
  > State Sharing
  > > Which parts of Java heap has changed
  > > Track the change set in a UOW
  > > Replicate the UOW to parts of the distributed env that need it
  > > Merge the change set into Java heap on other nodes
  > Thread Coordination
  > > maintain semantics of JMM 
  
 Java Clustering - Traditional Way
--------------------------------
  > use of Java Serialization to transfer data between different JVMs
  > Issues with Serialization
  > --- Creates Deep Copies ---
  > > Hence, breaks pass-by-reference semantics
  > > Hence, developers need to maintain the relational references between objects themselves
  > --- Coarse Grained ---
  > > No way to detect which parts of the Java heap has changed
  > > converts not only data but also java class structs, into network transportable format
  > > forces use of coarse grained locking mechanism





 Java Collections & Primitive Types
-----------------------------------
  > normally not supported
  > check out latest or external libraries



 Map --> Algorithms
----------------
  > Preserve insertion order - LinkedHashMap
  > Order by key - TreeMap
  > synchronized key value - HashTable
  > HOWEVER, ALL ABOVE DEPENDS ON HOW, KEY OBJECT'S HASHCODE & EQUALS IS IMPLEMENTED
  > FURTHER, FOR ORDERING, THE KEY OBJECT SHOULD EXTEND FROM COMPARABLE interface

 List --> Alogorithms
------------------------
  > resiable array - ArrayList
  > more add & remove ops - LinkedList
  > get & set ops - ArrayList
  > minize cost of resize in ArrayList - set a higher initial capacity
  > synchornize the list - Vector

 LinkedList --> Usage
------------------------
  > works good for observer pattern for a list of listeners
  > where we need to access listeners in a sequential order
  
 ArrayList --> Insertions
---------------------------
  > In Java its a pure Array
  > [2][3][4][5][][][][][]
  > insertions at end - fast
  > [2][3][4][5][6][][][][]
  > insertions @ first index or in between - slow  
  > when insert @ first etc, the entire values needs to be copied to their next slot
  > [6][2][3][4][5][][][][][]
  > Hence, expensive operation

 GapList --> optimized for get, set, add, remove
---------------------------------------------------
  > use Array as a rotating buffer
  > Insert @ first = Starts inserts @ the end
  > [6][2][3][4][5][][][][][1]
  > Next insert to first = Inserts last but one @ the end
  > [6][2][3][4][5][][][][2][1]
  > removal at beginning & at end, without recopying effort
  > Gaps are created if needed
  
 


 Detect Java Deadlock Threads
---------------------------------
  > ThreadMXBean
  
 Attach API
------------
  > A Sun Microsystems extension that provides a mechanism to attach to JVM
  > JConsole & VisualVM use the Attach API to attach to a target JVM
  > thread, OS, Runtime, Heap/Non-Heap memory can be extracted from JVM
  > can attach & detach as well

  Attach API located at
------------------------
  > ${JAVA_HOME}\lib\tools.jar or %JAVA_HOME\lib\tools.jar
 


 UseCases of Byte Modification
----------------------------------
  > in test env - force an app to generate dummy results
  > in test env - force an app to simulate an error
  > testing - simulation of machine crash
  > possible to read & write protected & private fields & call protected or private data
  > testing multi-threaded apps


 java.lang.Instrumentation
-----------------------------
  > JVM class loaders provide agents with an opportunity to modify loaded bytecode 
  > --> just prior to compilation
  > 


 Sizing JVM
------------
  > VM Memory = Guest OS Memory + JVM Memory
  > JVM Memory = Direct Native Memory + Non Direct Address Space
  > Direct Native Memory = Java Stack + Other Memory + Perm Gen
  > Non Direct Address Space = Heap Size

 Java OPTS
------------
  > -Xss per Thread - Java Stack
  > -XX:MaxPermSize - Perm Gen
  > -Xmx            - Max Heap
  > -Xms            - Initial Heap

 JVM --> Heap
-----------------
  > Composed of OldGen & YoungGen
  > OldGen --> Slower FULL GC
  > YoungGen = Survivor Space 1 +  Survivor Space 2 + Eden Space
  > YoungGen --> Eden Space --> Quick Minor GC


 JVM Memory - Equation
--------------------------
  > JVM Memory = JVM Max Heap (-Xmx value) + 
                 JVM Perm Size (-XX:MaxPermSize) +  
                 NumberOfConcurrentThreads * (-Xss) + 
                 "other Mem"

 > Other Memory
-----------------------
  > NIO Buffers
  > JIT Code Cache
  > classloaders
  > Socket Buffers (receive/send)
  > JNI
  > GC internal info

 Sizing  JVM --> Numbers --> Example
-------------------------------------
  > VM Mem = JVM Mem + OS Mem
  > --> 5088m  = 4588m   + 500m

  > JVM Mem = -Xss per Thread + Other Mem + Max PermSize + Heap
  > --> 4588m  = 256k*100 + 217m + 256m + 4096m

  > JVM Max Heap (-Xmx) = OldGen + YoungGen (-Xmn)
  > --> 4096m           = 27460m + 1350m
  > Put Initial & Max Heap as same

  > Max Heap Size ? Determine ?
----------------------------------
  > 3 to 4 times the Active Data
  > Active Data = Data Alive after a FULL GC
  > Then apply all of the relative sizing rules to other memory segments from this -Xmx
  
  GC Tuning
---------------
  > Measure Minor GC Duration & Frequency
  > --> Now adjust -Xmn Young Gen size &/or ParallelGCThreads
  > Measure major GC duration & frequency
  > --> Now adjust heap space -Xmx
  > Survivor Spaces Tuning
  > --> Adjust -Xmn &/or SurvivorSpaces


  Java -- InetAddress
------------------------
  > get local host
  > learn more on loopback & array of inet address

  Java -- InetAddress + Cache
--------------------------------
  > Have a look at Caching for IP resolution
  > Use of private Cache,CacheEntry related to InetAddress

  Java -- InetAddress + Enum
----------------------------
  > Simple usage of enum in Cache
  > Cache is tuned w.r.t InetAddress

  Java - HashMap + Synchronized
---------------------------------
  > Peek into InetAddress for using HashMap in a threadsafe manner

  Java - Wait X Notify
------------------------
  > About grabbing the monitor
  > put inside synchronized
  > notifyAll .. wakes up all Threads .. but only 1 grabs the Monitor

  Java - Wait vs Sleep
--------------------------
  > Wait on Object itself
  > --> Wait to grab the Object's Monitor
  > --> wait belongs to Object class
  > Sleep on Thread 
  > --> Sleep belongs to Thread class

  Java - Lock & Wait & Sleep
-----------------------------------
  > wait releases the lock on the Monitor
  > --> & goes to a waiting state
  > --> to be waked up by notify
  > Sleep locks the Thread

  Java - Inter-Thread Comm
---------------------------
  > Wait is used for inter-thread communication or synchronization
  > coz if a Thread goes into waiting
    > --> then another thread is requried to wake it up

  Java -- AccessController
----------------------------
  > java.security.AccessController
  > to give code priviledges that code earlier doesnot have

  Java -- Cache @ JVM
-------------------------
  > faster than JDBC or memcache etc
  > a ConcurrentHashMap<String, WeakReference<E>>
  > use of ObjectOutputStream

 Decorators vs Inheritance
-----------------------------
  > decorator is more flexible
  > attach behaviors @ runtime vs compile time




  Java -- Resolve Class
---------------------------
  String classname = objectStreamClass.getName();
  
  .. do basic string comparison with Java Primitives first ..
 
  ClassLoader loader = Thread.currentThread().getContextClassLoader();
  if (loader == null) {
    loader = ClassLoadingObjectInputStream.class.getClassLoader();
  }
  clazz = Class.forName(classname, false, loader);


 










References:
1/ Byteman
2/ http://www.infoq.com/presentations/Virtualizing-Tuning-JVM
