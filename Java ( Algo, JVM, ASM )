 To Read & references
-------------
  > http://java.dzone.com/articles/detecting-java-threads
  > http://jonasboner.com/publications/AOSD_2007_Final.pdf
  > http://jonasboner.com/publications/JVM_AOP_AOSD2006.pdf
  > cglib vs java agent ?  
	> http://www.infoq.com/presentations/Statically-Dynamic-Typing-Neal-Gafter  
	> http://www.myexpospace.com/JavaOne2012/SessionFiles/CON5251_PDF_5251_0001.pdf
	> JSR 269 - Annotation Processing
	> JSR 299 - Decorators
	> JSR 299/318 - Interceptors


JSR 269 -- Annotation Processing --
 Dagger - A DI not using Reflection
---------- ---------------------------------
	> One of the innovative things that Dagger does is instead of using reflection at runtime,
	> it uses code generation instead, so it actually generates the code that wires all your code together, 
	> which makes it a little easier to start up because loading classes tends to be faster 
	> and doesnâ€™t require so much work in the Java space. 
	>  It provides a JSR 269 based annotation processor which is used at compile time to create an adapter class
	> for each managed type. 
	> These adapter classes contain all the logic required at run time to set up the object graph
	> by invoking constructors and populating references to other objects, without making use of reflection.

	JSR 269 - Annotation Processing
-------------------------------------
	> Java 6
	> Pluggable Annotation Processing API
	> extends the java compiler with a plugin mechanism
	> Now write custom annotation processors that can be plugged in to the compilation process
	> java.lang.model.*
	> java.annotation.processing.*

 Bytecode Generation
------------------------
	> ASM
	> CGLIB --> top of --> ASM
	> BiteScript --> top of --> ASM
	> JiteScript --> top of --> ASM


 
  MethodHandles.Lookup
-------------------------
  > a factory for creating method handles
  > .findStatic -> creates a static method handle for the xxx method

  CallSite && Bootstrap method
-------------------------------
  > A dynamic callsite is linked to a method by a bootstrap method
  > A dynamic callsite's bootstrap method is a method SPECIFIED by the COMPILER
  > 4 the dynamically-typed language that is called once by the JVM 

  INdy Flow
----------------
  > JVM encounters the indy instruction
  > JVM calls the bootstrap method
  > Bootstrap links the name of the indy instruction with the target method i.e. a method handle
  > last 2 steps are done once only
  > next time when JVM encounters the same indy instruction, it executes the linked method handle
  





	Java Bytecode vs Java
--------------------------
	> though BC was designed keeping Java in mind
	> still BC is a general purpose bytecode
	> BC is infact more expressive than Java
	> this has been widely explioted in apps like obfuscation
	
	invokedynamic vs invokeinterface & invokevirtual
-----------------------------------------------------
	> indy is very soimilar to invokevirtual & invokeinterface
	> invokevirtual - based on receiver type i.e. overridden stuff
	> invokeinterface - based on the receiver type i.e. the one implementing the interface
	> so indy, invi & inin are all similiar w.r.t method dispatch is performed @ runtime
	> virtual & interface require receiver type
	> indy relazes this further - closer to function pointer semantics
	
	Bootstrap Instructions
	-----------------------
	> bind the Callsite with target to handle invocations
	> java.lang.invoke defined 2 new types
	> CallSite & MethodHandle




	CGLIB 
---------------------------------
	- built on top of ASM


  ASM - A Bytecode Framework
------------
  > approach to generate bytecode 
  > transform existing classes
  > so for developers they just need to code in Java
  > core package - read, write & transform bc
  > tree package - in-memory representation of bc
  > analysis pack - data-flow analysis ^ type-checking algo
  > commons pack - commonly used transformations & adapters
  > Util pack - helpers & verifiers for development & testing
  > XML pack - to & from <-> bytecode struct & XML <-> use of XSLT to define bytecode transformations
  > use of Chain of Responsibility - to affect/transform a particular flow
  
  InvokeDynamic vs BootstrapDynamic
------------------------------------------
  > InvokeDynamic to JVM
  > Bootstrap Dynamic - Bootstrap method performs dynamic linkage
  > ... dynamic linkage between calling class & receiving class
  > Bootstrap Method returns a Methodhandle that targets the receiving class
  > The MethodHandle is cached for repetitive invocations of xxx method


	Anonymous Class Loader - A imp peice of Indy
------------------------------------------------
	> generated bytecode to be contained in class
	> class to be contained in class loader
	> Class Loader keeps a hard reference to the class
	> This is required for GCing the bytecode
	> Classes are loaded without a Parent Class loader
	> So when the last reference to the class disappears, its eligible for GC
	
	

	MethodHandle - A imp piece of INDY
------------------------------------------
	> Instead of java.lang.reflect.Method
	> reflect.Method is slow coz it carries lot of metadata
	> MethodHandle is very primitive
	> represents a Specific Method on a Specific Type with Specific parmeters
	> But how will this help the dynamic languages where stuff happens @ runtime
	> So MethodHandle is better than relfect.Method for static java language

	MethodHandle for dynamic languages
---------------------------------------
	> MH provides currying
	> i.e. adapting a method	
	> either a direct reference to a class method or field
	> or refer to a chain of method handles called combinators

	CallSite - A IMP piece of INDY
----------------------------
	> has info - where in the original code the dynamic invocation came from
	> is the return value of the bootstrap process



 Java Instrumentation
--------------------------
  > Transformer
  > MBean Servlet 

  JVM + 4 opcodes
-------------------
  > invokestatic - for static methods
  > invokevirtual - based on the receiver type - i.e. public or protected methods
  > invokespecial - for private methods & constructors
  > invokeinterface - dispatch method to the instance implementing the interface
  > Now invokeDynamic - 5th opcode
 
 invokeDynamic
----------------
  > similar to invokevirtual or invokeinterface
  > i.e. method dispatch is performed @ runtime
  > dynamic languages need to resolve types, symbols & invocation targets

	Generating Method-Call bytecodes
---------------------------------------
  > provide method name, target class name, precise parameter list

	Does InvokeDynamic do this ?
--------------------------------------
  > with invokeDynamic, we defer this compile time magic to VM
  > VM in turn would look at params, & name & select an appropriate method from the receiving obj

 Java is static type
------------------------
  > All types should be mentioned for compilation to work
	> cannot just delegate to runtime intelligence

	Bit of bytecode
-----------------------
	> load - retrieve a local value & push to stack
	> store - pop off a value from stack & store into local variable
	> keep an eye on prefix - [a - reference, i - integer, f - float ..]
  > other r the 4 METHOD opcodes starting with invokeXXX
  > new opcode is invokeDynamic
	
	Prior to invokeDynamic - The Issues
---------------------------------------
	> invocations r statically typed i.e. method invocation signature must match
	> invocations must be against Java methods on Java types
	> traditional solution - java.lang.reflect package
	>	-->	reflect.Method accepts Object as Receiver, Return type & Arguments
	>	--> this has relative performance impact
	> JRuby solution - custom invoker classes for each method - that generates short bytecode opcodes
	> --> Generates many classes with similar bytecodes
	> --> But this Bytecode or JITed native code will be stored in Permgen
	> --> Permgen is never garbage collected
	
	java.dyn.AnonymousClassLoader
----------------------------------
	> generated bytecode contained in a class
	> class must be contained in a ClassLoader
	> hence, bytecode will be garbage collectible






 Threading & Non-deterministic Behavior
-------------------------------------------
  > Why ?
  > else Threads will accidentally share data & override each other data

 Thread + ReEntrantLock
---------------------------
  > lock blocks & wait till lock is ready
  > use of try finally to unlock
  > no synchronized block

 Thread + CountDownLatch
---------------------------
  > wait till countdown latch goes to 0
  > other thread need to call countDown()

 Thread + Semaphore
-----------------------
  > Can be binary if 1 permit
  > wait till the semaphore is available
  > same thread or other thread can release the semaphore .. no owner
  > no synchronized block


 When Annotations
---------------------
  > solving the solution via tuples
  > solving the solution via Map & if else condition
  > use annotation to do filtering & invoke the method if match found
 
 How Annotations
------------------
  > need to use reflection to capture the methods/fields
  > try to restrict the annotation to return String
  > may be try with exotic lambdas & annotations later
  
 How Annotation -- Example
-------------------------------
   @Retention(RetentionPolicy.RUNTIME)
   @Target(ElementType.METHOD)
   public @interface Match {
       String value();
   }
   
   ...
   final Match match = method.getAnnotation(Match.class);
               if (match != null) {
                ....

 


 Byteman --> Run Faster
-----------------------
  > tell Byteman to translate rule into bytecode
  > system property - org.jboss.byteman.compile.to.bytecode


 Byteman - JRE or JDK
----------
  > anyone
  > JDK when dynamic loading required

 Byteman - Run
-----------------
  > java -javaagent:${BYTEMAN_HOME}/lib/byteman.jar=script:appmain.btm org.my.AppMain foo bar baz
  > start executing Byteman scripts during JVM startup

 Byteman --> $0, $1, ...
--------------------------
  > $0 --> refers to the target i.e. join point
  > $1, $2 --> arguments of the point cuts of the target

 Byteman & Bootstrap class loader
--------------------------------
  > Class which gets loaded by the bootstrap classloader
  > Needs extra options for aspecting via Byteman
  > i.e. use of boot:...

 Byteman & Aspecting java.lang.*
-------------------------------------
  > Need to define system property for this
  > org.jboss.byteman.transform.all

 Byteman --> Simplified
--------------------------
  > Look running the bmjava.sh






 Groovy --> AOP 
--------------------
  > ProxyMetaClass - change behavior of already loaded classes
  > GroovyInterceptable - implement this interface - override invokeMethod()


 Customer Site Debugging & Analysis
--------------------------------------
  > http://youdebug.kenai.com/
  > Analyze w.r.t Byteman


  Groovy --> AST Transformations
-----------------------
  > hook into the compilation process to transform the code
  > add new methods, imports etc 
  > Test methods etc too can be added during compilation



 Fault Injection
----------------------
  > http://youdebug.kenai.com/
  > http://theholyjava.wordpress.com/2012/02/25/cool-tools-fault-injection-into-unit-tests-with-jboss-byteman-easier-testing-of-error-handling/
  > https://community.jboss.org/wiki/FaultInjectionTestingWithByteman


 Java AOP --> Traditional
----------------------------
  > either use a framework to modify byte-code of our own classes
  > or
  > create a proxy for our own classes (JDK Dynamic Proxies or CGLib)

 Groovy AOP --> MOP
---------------------
  > Metaobject-Protocol 
  > can intercept every single call to our objects without 
  > > the need for a proxy or byte-code manipulation


=====================Clustering========================================

 JVM --> Clustering
---------------------
  > hub-and-spoke
  > 1 central & various clients
  > central - tracks which node holds the lock
  > central - tracks which nodes reference which part of shared state
  > central - tracks which objects have not been used for a specific period & can be paged out
  > central - serves as a dedicated state database
  > central - itself is culsterable via a SAN-based failover mechanism
  > hub-and-spoke - no need to multicast like peer-to-peer

	Peer-2-Peer
---------------
	> Need to Multicast

  
 JVM --> Clustering --> state sharing & thread coordination
-------------------------------------------------------------
  > State Sharing
------------------
  > > Which parts of Java heap has changed
  > > Track the change set in a UOW
  > > Replicate the UOW to parts of the distributed env that need it
  > > Merge the change set into Java heap on other nodes
  > Thread Coordination
-----------------------
  > > maintain semantics of JMM 
  
 Java Clustering - Traditional Way
--------------------------------
  > use of Java Serialization to transfer data between different JVMs

	Issues with Serialization in Clustering
--------------------------------
  > Issue A --- Creates Deep Copies ---
  > > Hence, breaks pass-by-reference semantics
  > > Hence, developers need to maintain the relational references between objects themselves

  > Issue B --- Coarse Grained ---
  > > No way to detect which parts of the Java heap has changed
  > > converts not only data but also java class structs, into network transportable format
  > > forces use of coarse grained locking mechanism


======================AOP============================





===================================================================

 Java Collections & Primitive Types
-----------------------------------
  > normally not supported
  > check out latest or external libraries



 Map --> Algorithms
----------------
  > Preserve insertion order - LinkedHashMap
  > Order by key - TreeMap
  > synchronized key value - HashTable
  > HOWEVER, ALL ABOVE DEPENDS ON HOW, KEY OBJECT'S HASHCODE & EQUALS IS IMPLEMENTED
  > FURTHER, FOR ORDERING, THE KEY OBJECT SHOULD EXTEND FROM COMPARABLE interface

 List --> Alogorithms
------------------------
  > resiable array - ArrayList
  > more add & remove ops - LinkedList
  > get & set ops - ArrayList
  > minize cost of resize in ArrayList - set a higher initial capacity
  > synchornize the list - Vector

 LinkedList --> Usage
------------------------
  > works good for observer pattern for a list of listeners
  > where we need to access listeners in a sequential order
  
 ArrayList --> Insertions
---------------------------
  > In Java its a pure Array
  > [2][3][4][5][][][][][]
  > insertions at end - fast
  > [2][3][4][5][6][][][][]
  > insertions @ first index or in between - slow  
  > when insert @ first etc, the entire values needs to be copied to their next slot
  > [6][2][3][4][5][][][][][]
  > Hence, expensive operation

 GapList --> optimized for get, set, add, remove
---------------------------------------------------
  > use Array as a rotating buffer
  > Insert @ first = Starts inserts @ the end
  > [6][2][3][4][5][][][][][1]
  > Next insert to first = Inserts last but one @ the end
  > [6][2][3][4][5][][][][2][1]
  > removal at beginning & at end, without recopying effort
  > Gaps are created if needed
  
 


 Detect Java Deadlock Threads
---------------------------------
  > ThreadMXBean
  
 Attach API
------------
  > A Sun Microsystems extension that provides a mechanism to attach to JVM
  > JConsole & VisualVM use the Attach API to attach to a target JVM
  > thread, OS, Runtime, Heap/Non-Heap memory can be extracted from JVM
  > can attach & detach as well

  Attach API located at
------------------------
  > ${JAVA_HOME}\lib\tools.jar or %JAVA_HOME\lib\tools.jar
 


 UseCases of Byte Modification
----------------------------------
  > in test env - force an app to generate dummy results
  > in test env - force an app to simulate an error
  > testing - simulation of machine crash
  > possible to read & write protected & private fields & call protected or private data
  > testing multi-threaded apps


 java.lang.Instrumentation
-----------------------------
  > JVM class loaders provide agents with an opportunity to modify loaded bytecode 
  > --> just prior to compilation
  > 


 Sizing JVM
------------
  > VM Memory = Guest OS Memory + JVM Memory
  > JVM Memory = Direct Native Memory + Non Direct Address Space
  > Direct Native Memory = Java Stack + Other Memory + Perm Gen
  > Non Direct Address Space = Heap Size

 Java OPTS
------------
  > -Xss per Thread - Java Stack
  > -XX:MaxPermSize - Perm Gen
  > -Xmx            - Max Heap
  > -Xms            - Initial Heap

 JVM --> Heap
-----------------
  > Composed of OldGen & YoungGen
  > OldGen --> Slower FULL GC
  > YoungGen = Survivor Space 1 +  Survivor Space 2 + Eden Space
  > YoungGen --> Eden Space --> Quick Minor GC


 JVM Memory - Equation
--------------------------
  > JVM Memory = JVM Max Heap (-Xmx value) + 
                 JVM Perm Size (-XX:MaxPermSize) +  
                 NumberOfConcurrentThreads * (-Xss) + 
                 "other Mem"

 > Other Memory
-----------------------
  > NIO Buffers
  > JIT Code Cache
  > classloaders
  > Socket Buffers (receive/send)
  > JNI
  > GC internal info

 Sizing  JVM --> Numbers --> Example
-------------------------------------
  > VM Mem = JVM Mem + OS Mem
  > --> 5088m  = 4588m   + 500m

  > JVM Mem = -Xss per Thread + Other Mem + Max PermSize + Heap
  > --> 4588m  = 256k*100 + 217m + 256m + 4096m

  > JVM Max Heap (-Xmx) = OldGen + YoungGen (-Xmn)
  > --> 4096m           = 27460m + 1350m
  > Put Initial & Max Heap as same

  > Max Heap Size ? Determine ?
----------------------------------
  > 3 to 4 times the Active Data
  > Active Data = Data Alive after a FULL GC
  > Then apply all of the relative sizing rules to other memory segments from this -Xmx
  
  GC Tuning
---------------
  > Measure Minor GC Duration & Frequency
  > --> Now adjust -Xmn Young Gen size &/or ParallelGCThreads
  > Measure major GC duration & frequency
  > --> Now adjust heap space -Xmx
  > Survivor Spaces Tuning
  > --> Adjust -Xmn &/or SurvivorSpaces


 Eden -to- ToSurvivor
---------------------
  > Retention / aging of young objects during minor GCs

 ToSurvivor -to- OldGeneration
---------------------------------
  > promotion of longer lived objects during minor GCs
 
 GCs love ?
------------------------------
  > small immutable objects
  > short lived objects
  > these seldom survive a minor GC

 GC -- Lifecycle
------------------
 - More frequent allocations means more frequent GCs
 - frequent GCs means faster object ageing
	- which in turn means faster promotions
	- which in turn means more old generation collection
	- or old generation compaction (i.e full GC)

	A imp GC JAVA_OPTS
-------------------------
	-verbose:gc --> get gc output
	-Xloggc:<pathtofile>  --> path to log file
	
	Why GC log File ?
-------------------------
	> log file can be post processed
	> has more info than MXBeans
	> Runtime MX Beans impact the running app

	GC log format
--------------------
	from->to(totalsize)
	e.g. 12121K->22K(132121K)

	occupany(size)
	e.g. 32322K(87878K)

	Increase Heap Size to solve your problem. Is it ?
--------------------------------------------
	- If the app produces a lot of objects with a short lifespan of 2 to 3 seconds
	- If allocation rate is high then GC could occur so rapidly that these objects r promoted into tenured generation
	- Tenured = old generation
	- Once in tenured, the objects die almost immediately, but will be collected until next full GC
	- If we increase heap size, then this next Full GC will increase the Stop-The-World pause time period
	

	Dev or Prod... What should be our GC params
---------------------------------------------------
	.. should have atleast below flags

	-verbose:gc //print GC logs
	-Xloggc:	//more GC logging
	-XX:+PrintGCDetails	//detailed o/p
	-XX:+PrintTenuringDistribution	//displays tenuring thresholds 


 Free Resources Explicitly
----------------------------
 - Use ReferenceObjects as an alternative
 - See DirectByteBuffer.java







  Java -- InetAddress
------------------------
  > get local host
  > learn more on loopback & array of inet address

  Java -- InetAddress + Cache
--------------------------------
  > Have a look at Caching for IP resolution
  > Use of private Cache,CacheEntry related to InetAddress

  Java -- InetAddress + Enum
----------------------------
  > Simple usage of enum in Cache
  > Cache is tuned w.r.t InetAddress

  Java - HashMap + Synchronized
---------------------------------
  > Peek into InetAddress for using HashMap in a threadsafe manner

  Java - Wait X Notify
------------------------
  > About grabbing the monitor
  > put inside synchronized
  > notifyAll .. wakes up all Threads .. but only 1 grabs the Monitor

  Java - Wait vs Sleep
--------------------------
  > Wait on Object itself
  > --> Wait to grab the Object's Monitor
  > --> wait belongs to Object class
  > Sleep on Thread 
  > --> Sleep belongs to Thread class

  Java - Lock & Wait & Sleep
-----------------------------------
  > wait releases the lock on the Monitor
  > --> & goes to a waiting state
  > --> to be waked up by notify
  > Sleep locks the Thread

  Java - Inter-Thread Comm
---------------------------
  > Wait is used for inter-thread communication or synchronization
  > coz if a Thread goes into waiting
    > --> then another thread is requried to wake it up

  Java -- AccessController
----------------------------
  > java.security.AccessController
  > to give code priviledges that code earlier doesnot have

  Java -- Cache @ JVM
-------------------------
  > faster than JDBC or memcache etc
  > a ConcurrentHashMap<String, WeakReference<E>>
  > use of ObjectOutputStream

 Decorators vs Inheritance
-----------------------------
  > decorator is more flexible
  > attach behaviors @ runtime vs compile time




  Java -- Resolve Class
---------------------------
  String classname = objectStreamClass.getName();
  
  .. do basic string comparison with Java Primitives first ..
 
  ClassLoader loader = Thread.currentThread().getContextClassLoader();
  if (loader == null) {
    loader = ClassLoadingObjectInputStream.class.getClassLoader();
  }
  clazz = Class.forName(classname, false, loader);


  Design behind XML parsing
------------------------------
  > Visitor Design Pattern
  > used in SAX API
  > Used in ASM to navigate byte structure
  > Then you got producers or consumers
  > producers to read
  > consumers to write












References:
1/ Byteman
2/ http://www.infoq.com/presentations/Virtualizing-Tuning-JVM
