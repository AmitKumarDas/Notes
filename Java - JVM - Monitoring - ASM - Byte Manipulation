
 To Read
-------------
  > http://java.dzone.com/articles/detecting-java-threads


 


 UseCases of Byte Modification
----------------------------------
  > in test env - force an app to generate dummy results
  > in test env - force an app to simulate an error
  > testing - simulation of machine crash
  > possible to read & write protected & private fields & call protected or private data
  > testing multi-threaded apps


 java.lang.Instrumentation
-----------------------------
  > JVM class loaders provide agents with an opportunity to modify loaded bytecode 
  > --> just prior to compilation
  > 


 Sizing JVM
------------
  > VM Memory = Guest OS Memory + JVM Memory
  > JVM Memory = Direct Native Memory + Non Direct Address Space
  > Direct Native Memory = Java Stack + Other Memory + Perm Gen
  > Non Direct Address Space = Heap Size

 Java OPTS
------------
  > -Xss per Thread - Java Stack
  > -XX:MaxPermSize - Perm Gen
  > -Xmx            - Max Heap
  > -Xms            - Initial Heap

 JVM --> Heap
-----------------
  > Composed of OldGen & YoungGen
  > OldGen --> Slower FULL GC
  > YoungGen = Survivor Space 1 +  Survivor Space 2 + Eden Space
  > YoungGen --> Eden Space --> Quick Minor GC


 JVM Memory - Equation
--------------------------
  > JVM Memory = JVM Max Heap (-Xmx value) + 
                 JVM Perm Size (-XX:MaxPermSize) +  
                 NumberOfConcurrentThreads * (-Xss) + 
                 "other Mem"

 > Other Memory
-----------------------
  > NIO Buffers
  > JIT Code Cache
  > classloaders
  > Socket Buffers (receive/send)
  > JNI
  > GC internal info

 Sizing  JVM --> Numbers --> Example
-------------------------------------
  > VM Mem = JVM Mem + OS Mem
  > --> 5088m  = 4588m   + 500m

  > JVM Mem = -Xss per Thread + Other Mem + Max PermSize + Heap
  > --> 4588m  = 256k*100 + 217m + 256m + 4096m

  > JVM Max Heap (-Xmx) = OldGen + YoungGen (-Xmn)
  > --> 4096m           = 27460m + 1350m
  > Put Initial & Max Heap as same

  > Max Heap Size ? Determine ?
----------------------------------
  > 3 to 4 times the Active Data
  > Active Data = Data Alive after a FULL GC
  > Then apply all of the relative sizing rules to other memory segments from this -Xmx
  
  GC Tuning
---------------
  > Measure Minor GC Duration & Frequency
  > --> Now adjust -Xmn Young Gen size &/or ParallelGCThreads
  > Measure major GC duration & frequency
  > --> Now adjust heap space -Xmx
  > Survivor Spaces Tuning
  > --> Adjust -Xmn &/or SurvivorSpaces


  Java -- InetAddress
------------------------
  > get local host
  > learn more on loopback & array of inet address

  Java -- InetAddress + Cache
--------------------------------
  > Have a look at Caching for IP resolution
  > Use of private Cache,CacheEntry related to InetAddress

  Java -- InetAddress + Enum
----------------------------
  > Simple usage of enum in Cache
  > Cache is tuned w.r.t InetAddress

  Java - HashMap + Synchronized
---------------------------------
  > Peek into InetAddress for using HashMap in a threadsafe manner

  Java - Wait X Notify
------------------------
  > About grabbing the monitor
  > put inside synchronized
  > notifyAll .. wakes up all Threads .. but only 1 grabs the Monitor

  Java - Wait vs Sleep
--------------------------
  > Wait on Object itself
  > --> Wait to grab the Object's Monitor
  > --> wait belongs to Object class
  > Sleep on Thread 
  > --> Sleep belongs to Thread class

  Java - Lock & Wait & Sleep
-----------------------------------
  > wait releases the lock on the Monitor
  > --> & goes to a waiting state
  > --> to be waked up by notify
  > Sleep locks the Thread

  Java - Inter-Thread Comm
---------------------------
  > Wait is used for inter-thread communication or synchronization
  > coz if a Thread goes into waiting
    > --> then another thread is requried to wake it up

  Java -- AccessController
----------------------------
  > java.security.AccessController
  > to give code priviledges that code earlier doesnot have

  Java -- Cache @ JVM
-------------------------
  > faster than JDBC or memcache etc
  > a ConcurrentHashMap<String, WeakReference<E>>
  > use of ObjectOutputStream

  Java -- Resolve Class
---------------------------
  String classname = objectStreamClass.getName();
  
  .. do basic string comparison with Java Primitives first ..
 
  ClassLoader loader = Thread.currentThread().getContextClassLoader();
  if (loader == null) {
    loader = ClassLoadingObjectInputStream.class.getClassLoader();
  }
  clazz = Class.forName(classname, false, loader);


 










References:
1/ Byteman
2/ http://www.infoq.com/presentations/Virtualizing-Tuning-JVM
