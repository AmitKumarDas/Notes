 -0 STICKY
----------------

def  <=> function
self <=> this
All about indentations
__init__
__del__
() <=> new operator
() & del <=> create & destroy object
self <=> prefix to variable & it becomes a instance variable
self <=> as an argument in a method then it becomes an instance method
self <=> not present in argument then it becomes a static method
__ <=> double underscore for data members are private
http://pythontutor.com/visualize.html#


 -0 *args = varargs
-----------------------------
def print_everything(*args):
        for count, thing in enumerate(args):
           print '{0}. {1}'.format(count, thing)

  > print_everything('apple', 'banana', 'cabbage')
  > see the usage of count & thing ... implicit

 -0 **kwargs = named varargs
-----------------------------
def table_things(**kwargs):
       for name, value in kwargs.items():
           print '{0} = {1}'.format(name, value)

  > table_things(apple = 'fruit', cabbage = 'vegetable')
  > name & value - implicit


 -0 *list
-------------------------
def print_three_things(a, b, c):
     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)


  > mylist = ['aardvark', 'baboon', 'cat']
  > print_three_things(*mylist)


 -0 *args && **kwargs - Decorator
-----------------------------------
def mydecorator( f ):
   @functools.wraps( f )
   def wrapper( *args, **kwargs ):
      print "Calling f", args, kwargs
      v = f( *args, **kwargs )
      print "f returned", v
      return v
   return wrapper


 -0 Package Coroutine inside Thread
-----------------------------------
@coroutine
def threaded(target):
    messages = Queue()
    def run_target():
        while True:
            item = messages.get()
            if item is GeneratorExit:
                target.close()
                return
            else:
                target.send(item)
    Thread(target=run_target).start()
    try:
        while True:
            item = (yield)
            messages.put(item)
    except GeneratorExit:
        messages.put(GeneratorExit)


 -0 Parsing XML to Dictionary
-------------------------------------
@coroutine
def buses_to_dicts(target):
    while True:
        event, value = (yield)
        # Look for the start of a <bus> element
        if event == 'start' and value[0] == 'bus':
            busdict = { }
            fragments = []
            # Capture text of inner elements in a dict
            while True:
                event, value = (yield)
                if event == 'start':   fragments = []
                elif event == 'text':  fragments.append(value)
                elif event == 'end':
                    if value != 'bus': 
                        busdict[value] = "".join(fragments)
                    else:
                        target.send(busdict)
                        break

 -0 Check particular element & value
-----------------------------------------
@coroutine
def filter_on_field(fieldname,value,target):
    while True:
        d = (yield)
        if d.get(fieldname) == value:
            target.send(d)


 -0 Sink
-----------------------------------------------------
@coroutine
def bus_locations():
    while True:
        bus = (yield)
        print "%(route)s,%(id)s,\"%(direction)s\","\
              "%(latitude)s,%(longitude)s" % bus 


 -0 Finale Usage
---------------------------------------------------
xml.sax.parse("allroutes.xml", EventHandler(
     buses_to_dicts(
     threaded(
        filter_on_field("route","22",
        filter_on_field("direction","North Bound",
        bus_locations()))
     ))))

 >> CAUTION - ADDING THREADS MAKE THIS EXAMPLE RUN SLOWER ...


 -0 Bridge coroutine over file/pipe
----------------------------------------
@coroutine
def sendto(f):
    try:
        while True:
            item = (yield)
            pickle.dump(item,f)
            f.flush()
    except StopIteration:
        f.close()
def recvfrom(f,target):
    try:
        while True:
            item = pickle.load(f)
            target.send(item)
    except EOFError:
        target.close()



 -0 Tuples 
--------------------
 > are immutable
 > hold multiple objects
 > tuple within a tuple doesnot lose its identity
 > access item using SQUARE bracket
 > constructed using ()


 -0 Dictionary
--------------------
 > constructed via {}
 > use SQUARE bracket


 -0 List
---------------------------
 > constructed using []
 > use SQUARE bracket


 -0 Sequences
------------------------
 > full slice or copy => [:]
 > last item          => [-1]


 -0 Reference
-----------------------------
 > only reference & not copies
 > use full slice to get a copy


 -0 Join
----------------------------------
  > seems to be a cool string util method

Native Python Library vs C Library
  > try c library first if available
  > else use python
  > try: ... except:


[]
-----------
  > use .append
  > to append object

Inheritance
----------------
  > can be modeled like GENERICS


Serialization
--------------
  > pickle or cPickle library
  > data for the instance is pickled
  > class definition is not pickled

Simulate Stream
----------------
  > use StringIO

Circuar References
-------------------
  > pickle can serialize .. No Problem




Simulate FILE
------------------
  > use StringIO

Workers
-------------
  > os.fork()
  > os.pipe()


Worker Pool Manager
------------------
  > multiprocessing library
  > 












Ref - http://www.dabeaz.com/coroutines/Coroutines.pdf
