 -0 STICKY
----------------

def  <=> function
self <=> this
All about indentations
__init__
__del__
() <=> new operator
() & del <=> create & destroy object
self <=> prefix to variable & it becomes a instance variable
self <=> as an argument in a method then it becomes an instance method
self <=> not present in argument then it becomes a static method
__ <=> double underscore for data members are private
http://pythontutor.com/visualize.html#
[] <=> list
() <=> Tuple
{} <=> dictionary


 -0 subprocess
-----------------------

 -0 subprocess - some gyan first
------------------------------------
  > when terminal is clicked
  >> u load a program which in turn loads a shell
  >> commands are not interpreted via Shell to the Kernel
  > Command -> Terminal Program -> Shell -> Kernel
 
  I/O Channel
-------------------------------
  >> I/O Channels = streams
  >> stdio : 0, stdout = 1, stderr = 2
  
  PIPE
-------------
  > allows stdout from 1 program to be fed as stdio of another program
  > no need for temporary file

 -0 subprocess module in Py
-----------------------------
  > 


 -0 __init__ & options/settings
----------------------------------
def __init__(self, settings):
        self.channel_name = settings['channel_name']
        self.time_periods = settings['time_periods']




 -0 *args = varargs
-----------------------------
def print_everything(*args):
        for count, thing in enumerate(args):
           print '{0}. {1}'.format(count, thing)

  > print_everything('apple', 'banana', 'cabbage')


 -0 **kwargs = named varargs
-----------------------------
def table_things(**kwargs):
       for name, value in kwargs.items():
           print '{0} = {1}'.format(name, value)

  > table_things(apple = 'fruit', cabbage = 'vegetable')


 -0 *list
-------------------------
def print_three_things(a, b, c):
     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)


  > mylist = ['aardvark', 'baboon', 'cat']
  > print_three_things(*mylist)


 -0 *args && **kwargs - Decorator && callback
-----------------------------------
def __call__(self, *args, **kwargs):
        # Make a copy in case the callback wants to remove itself from
        # the list, since we can't iterate over a modified list.
        callbacks = self._callbacks[:]
        for callback in callbacks:
            callback(*args, **kwargs)

 -0 Functional
-------------------
def do_binary_op(op,x,y):
       return op(x,y)


 -0 Decorator
-------------------
  > defining a decorator is easy 
  > u got the annotations too

 -0 Lambda - Anonymous Functions
----------------------------------
  > declare short functions
  > is_odd = lambda x: x % 2
  > 




 -0 Package Coroutine inside Thread
-----------------------------------
@coroutine
def threaded(target):
    messages = Queue()
    def run_target():
        while True:
            item = messages.get()
            if item is GeneratorExit:
                target.close()
                return
            else:
                target.send(item)
    Thread(target=run_target).start()
    try:
        while True:
            item = (yield)
            messages.put(item)
    except GeneratorExit:
        messages.put(GeneratorExit)


 -0 Parsing XML to Dictionary
-------------------------------------
@coroutine
def buses_to_dicts(target):
    while True:
        event, value = (yield)
        # Look for the start of a <bus> element
        if event == 'start' and value[0] == 'bus':
            busdict = { }
            fragments = []
            # Capture text of inner elements in a dict
            while True:
                event, value = (yield)
                if event == 'start':   fragments = []
                elif event == 'text':  fragments.append(value)
                elif event == 'end':
                    if value != 'bus': 
                        busdict[value] = "".join(fragments)
                    else:
                        target.send(busdict)
                        break

 -0 Check particular element & value
-----------------------------------------
@coroutine
def filter_on_field(fieldname,value,target):
    while True:
        d = (yield)
        if d.get(fieldname) == value:
            target.send(d)


 -0 Sink
-----------------------------------------------------
@coroutine
def bus_locations():
    while True:
        bus = (yield)
        print "%(route)s,%(id)s,\"%(direction)s\","\
              "%(latitude)s,%(longitude)s" % bus 


 -0 Finale Usage
---------------------------------------------------
xml.sax.parse("allroutes.xml", EventHandler(
     buses_to_dicts(
     threaded(
        filter_on_field("route","22",
        filter_on_field("direction","North Bound",
        bus_locations()))
     ))))

 >> CAUTION - ADDING THREADS MAKE THIS EXAMPLE RUN SLOWER ...


 -0 Bridge coroutine over file/pipe
----------------------------------------
@coroutine
def sendto(f):
    try:
        while True:
            item = (yield)
            pickle.dump(item,f)
            f.flush()
    except StopIteration:
        f.close()
def recvfrom(f,target):
    try:
        while True:
            item = pickle.load(f)
            target.send(item)
    except EOFError:
        target.close()

 -0 gevent
-----------------------
import gevent
import random

def task(pid):
    """
    Some non-deterministic task
    """
    gevent.sleep(random.randint(0,2)*0.001)
    print('Task', pid, 'done')

def synchronous():
    for i in range(1,10):
        task(i)

def asynchronous():
    threads = [gevent.spawn(task, i) for i in xrange(10)]
    gevent.joinall(threads)

print('Synchronous:')
synchronous()

print('Asynchronous:')
asynchronous()

  > In fact the maximum time for the synchronous case to complete is 
  >> when each tasks pauses for 2 seconds resulting in a 20 seconds for the whole queue.
  > In the async case the maximum runtime is roughly 2 seconds 
  >> since none of the tasks block the execution of the others.

 -0 Multiprocessing Pool vs Gevent Pool
---------------------------------------
  > Non Deterministic Process Pool
  > Deterministic Gevent Pool

 -0 Runtime Modification
----------------------------
  > python's runtime can modify most of the objects @ runtime
  > modules, classes & even functions @ runtime
  > similar to proxying
  > useful for AOP concern
  > convert blocking system calls to cooperative behavior




 -0 Tuples 
--------------------
 > are immutable
 > hold multiple objects
 > tuple within a tuple doesnot lose its identity
 > access item using SQUARE bracket
 > constructed using ()


 -0 Dictionary
--------------------
 > constructed via {}
 > use SQUARE bracket


 -0 List
---------------------------
 > constructed using []
 > use SQUARE bracket


 -0 Sequences
------------------------
 > full slice or copy => [:]
 > last item          => [-1]


 -0 Reference
-----------------------------
 > only reference & not copies
 > use full slice to get a copy


 -0 Join
----------------------------------
  > seems to be a cool string util method

 -0 Native Python Library vs C Library
------------------------------------------
  > try c library first if available
  > else use python
  > try: ... except:


[]
-----------
  > use .append
  > to append object

Inheritance
----------------
  > can be modeled like GENERICS


Serialization
--------------
  > pickle or cPickle library
  > data for the instance is pickled
  > class definition is not pickled

Simulate Stream
----------------
  > use StringIO

Circuar References
-------------------
  > pickle can serialize .. No Problem




Simulate FILE
------------------
  > use StringIO

Workers
-------------
  > os.fork()
  > os.pipe()


Worker Pool Manager
------------------
  > multiprocessing library
  > 












Ref - http://www.dabeaz.com/coroutines/Coroutines.pdf
