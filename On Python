 -0 STICKY
----------------

def  <=> function
self <=> this
All about indentations
__init__
__del__
() <=> new operator
() & del <=> create & destroy object
self <=> prefix to variable & it becomes a instance variable
self <=> as an argument in a method then it becomes an instance method
self <=> not present in argument then it becomes a static method
__ <=> double underscore for data members are private


 -0 *args = varargs
-----------------------------
def print_everything(*args):
        for count, thing in enumerate(args):
           print '{0}. {1}'.format(count, thing)

  > print_everything('apple', 'banana', 'cabbage')
  > see the usage of count & thing ... implicit

 -0 **kwargs = named varargs
-----------------------------
def table_things(**kwargs):
       for name, value in kwargs.items():
           print '{0} = {1}'.format(name, value)

  > table_things(apple = 'fruit', cabbage = 'vegetable')
  > name & value - implicit


 -0 *list
-------------------------
def print_three_things(a, b, c):
     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)


  > mylist = ['aardvark', 'baboon', 'cat']
  > print_three_things(*mylist)


 -0 *args && **kwargs - Decorator
-----------------------------------
def mydecorator( f ):
   @functools.wraps( f )
   def wrapper( *args, **kwargs ):
      print "Calling f", args, kwargs
      v = f( *args, **kwargs )
      print "f returned", v
      return v
   return wrapper











 -0 Tuples 
--------------------
 > are immutable
 > hold multiple objects
 > tuple within a tuple doesnot lose its identity
 > access item using SQUARE bracket
 > constructed using ()


 -0 Dictionary
--------------------
 > constructed via {}
 > use SQUARE bracket


 -0 List
---------------------------
 > constructed using []
 > use SQUARE bracket


 -0 Sequences
------------------------
 > full slice or copy => [:]
 > last item          => [-1]


 -0 Reference
-----------------------------
 > only reference & not copies
 > use full slice to get a copy


 -0 Join
----------------------------------
  > seems to be a cool string util method

Native Python Library vs C Library
  > try c library first if available
  > else use python
  > try: ... except:


[]
-----------
  > use .append
  > to append object

Inheritance
----------------
  > can be modeled like GENERICS


Serialization
--------------
  > pickle or cPickle library
  > data for the instance is pickled
  > class definition is not pickled

Simulate Stream
----------------
  > use StringIO

Circuar References
-------------------
  > pickle can serialize .. No Problem




Simulate FILE
------------------
  > use StringIO

Workers
-------------
  > os.fork()
  > os.pipe()


Worker Pool Manager
------------------
  > multiprocessing library
  > 













