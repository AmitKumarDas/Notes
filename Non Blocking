 -0- Asyncore 
------------------
  > multiple asynchronouz connections
  > in the same OS thread





-0- Green threads
-------------------
  > Emulate multi-threaded environments 
  > NO relying on native OS capabilities, 
  > and they are managed in user space instead of kernel space, 
  > enabling them to work in environments that do not have native thread support.

 -0- Green Threads
---------------------
  > known as Space Threads or Fibers
  > manage concurrency in a COOPERATIVE than PRE-EMPTIVE WAY

 -0- Python's threads
----------------------
  > are implemented as pthreads (kernel threads) 
  > and because of the Global Interpreter Lock (GIL), 
  > A python process only runs ONE THREAD at a time.


 -0- Green Threads && Evented IO
------------------------------------
  > focussed on multi-tasking
  > no overhead of OS based multi-tasking
  
 -0-  Evented IO
---------------------
  > lets the server to continue work
  > it waits for the IO ops
  > deals with the IO events
  

 -0- Green Threads via CoRoutines 
----------------------------------
  > green threads resemble coroutines
  > HOW ?
  > both start & stop @ arbitary, programmer specified points


 -0 Coroutines
-------------------
  > used 2 express Simulations, Games, Async I/O, Event Driven Programming, co-operative multitasking
  > 

 -0 Python Generators
------------------------
  > differ from coroutine
  > donot pass values on resuming
  > donot pass exception on resuming
  > Just pause execution to produce a value
  > No clean up coz pause cannot be within try block


 -0 Python Generator - OLD REFERENCE
------------------------
  > yield to its immediate caller
  > cannot put out as a separate function
  > else the called function itself becomes a generator


 -0 Python Generator - New
------------------------------
  > yield from <expr>
  > <expr> ~ Iterable
  > value that the iterator yeilds is passed to the caller
  > value sent to the delegating generator passed directly to the Iterator
  > send() used to pass value to Iterator
  > 


 -0- Bluelet 
----------------
  > pure python
  > implements Green Threads as native coroutines
  > simple evented socket IO support via native coroutine

 -0- Bluelet vs Greenlet
------------------------
  > Greenlet - more powerful
  > relies on C extension to the Python interpreter



 -0 extract from InputStream
--------------------------------
  > URL can open an input stream
  > FileInputStream is an input stream
  > You read from input stream & dump into some native object

 -0 Serialization & Stream
----------------------------
  > Who takes cares of serialization
  > Just reading from Input Stream
  > & then dump/load into Object
  > Which Object ? How Serialization & DeSerialization is taken care?

 -0 Stream Serialization & DeSerialization
---------------------------------------------
  > input stream is verified against a particular object
  > i/p stream is typecasted to a particular object


0-0 Scripts Block Downloads 0-0-0
--------------------------
+ scripts take time to download
+ however, it blocks downloads of other resources
+ How to overcome this issue?

0-0 Non-Blocking scripts -0-0-
----------------------------
+ include scripts dynamically via DOM methods
+ simply create a new <script> element & append it to the <head>

-0- Do stylesheets BLOCK ? -0-0-
-------------------------------
- they dont in IE
- they do block in FF

0-0-0- Other Ways to Non-Blocking scripts -0-0-
--------------------------------------------------
+ defer - unreliable

+ document.write() - not recommended coding practice

+ XMLHttpRequest to get the source & then execute within eval() 
-> eval() is evil
-> same-domain policy restriction

+ XHR request to get source, create a new script tag, set its content 
-> more complex
-> same-domain policy 

+ Load script in an iframe - complex, iframe overhead, same-domain policy


-0- Event Loop -0-
+ The event loop is a way of having a non-blocking I/O (NIO in Java parlance) 
--> and to allow your application to scale more effectively by offloading I/O activities
--> to native functions in the operating system.

-0- Event Loop + Java + Example -0-
+ So the java.nio packages implement some of the key-functionality 
--> and we use the Netty framework. 
--> Netty builds utility classes and functions on top of NIO 
--> which make it much easier to work with that programming model

-0- Avoid blocking the Event Thread .. HOW ? ? -0--
+ The typical pattern is to implement a callback and this is what they underlying structure in Java is doing, 
--> they select the selection keys and you get an event of a selector
--> and then you can work with the events. 
--> If it’s a socket then you listen on a server socket, 
--> you get an event telling you there has been a connect event 
--> and you create a new socket channel. 
--> Because you can place a request, it’s not a queue, 
--> but if you place a request to be notified when something has happened, 
--> you can then go off and do other work until that event arrives and then you go back and pick the data up or respond in some way. 

-0- How to handle Blocking APIs ? -0-
--> For newer applications where there is async we can do implementations straight away, 
++ --> but when there are things like JDBC, <--
--> there is not a non-blocking JDBC implementation that I’m aware of, 
--> so we have to handle that slightly differently in vert.x, 
--> so rather than having one event loop, one thread pool that is engaged in that activity, 
--> we have to have a second pool of threads which we call the worker pool. 


--> Some Implementation 4 blocking APIs <--
And the worker pool has typically more threads in it, 
but it still listens on the EventBus and it still has all the same capabilities 
but we separate them out, so that you can make a decision to put your blocking activity in a pool 
with more threads available to it, in the knowledge that the rest of your application can remain async. 
So we have a pragmatic view of how to handle this and 
this also means that we have access to the rest of the Java ecosystem in terms of libraries
because significant numbers of those are not non-blocking implementations.

-0- What about Actor Model -0-
- one of the things we looked at was how best to handle handlers. 
- Do we do the same things as we’ve done in Groovy which is passing closures or Scala functions or can we use actors?



References:
1. http://yuiblog.com/blog/2008/07/22/non-blocking-scripts/
2. http://www.infoq.com/interviews/williams-vertx
