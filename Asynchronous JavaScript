This note is a collage of blogs & writeups of various Authors on JavaScript w.r.t asynchronous behavior.
I have tried to give due references of the Authors but might have missed others.

 -0- Node JS - radical approach
----------------------------------
  > no threads but only async I/O


-0  2 styles to do async stuff 
----------------------------------

  > 1/ event based
  > 2/ callback based

-0 Event style - A non-local approach 
--------------------------------------
 
  > Event style - emit @ some point & have listeners & act thereupon
  > Event Style - works well with Http client & server
  > Can U have event style for handling Biz logic
  > i.e. NON LOCAL BIZ LOGIC

-0- Callback based 
---------------------
  > is A local approach


 -0 Async Funcs & Serial invocation
----------------------------------------
 + If invoked in a loop i.e. serially
  > will execute parallely
  > Can you get the Aggregate results in such a case ?
  > No. The solution is to invoke the async funcs Recursively.
  > Coz Iteration will not give you results.

 -0 Recursion & Async
--------------------------
  > Recursive function should invoke Async Func

 -0 Recursive + Async + Functional
-------------------------------------
  > Define a for each function for async calls

asyncForEach(array,iterator,then){
 function loop(i){
  if(i < array.length) 
   iterator(array[i], function(){loop(i+1)};); // Invoke iterator
  else 
   then(); //aliter- invoke then
 }
 loop(0);
}

  > Invoke the for each function
  > Iterator takes the current item & also has the function that has to be invoked next

asyncForEach(array, function(item, next) {
  // body of iterator
  somethingAsync(function(err, result) {
    if (err) {callback(err); return; } 

    // do something with item and result

    next(); // don't forget me at the end of every code path

  });
}, function() {
  // body of then
});



 0- Callbacks & Templates II
---------------------------------------
+ function template(abc, options, callback){
  otherFunc(abc, function(err,data){
   if(err) return callback(err); // Invoked CB
 
   callback.counter +=1;         // A CB property defined & Assigned

   if(done) callback(null, callback.files); // CB signature defined // && Invoked CB

  });

}


  -0- Using callbacks 
-------------------------------
  + My exp in Spiffy tells that single callback will not suffice.
  + Read further to understand

 -0 Callbacks + Wrong way
-----------------------------

function fetch() {
  var result = 'snap!';
  $.getJSON("http://.....", function messyCallback(data){
    result = data;
  });
  return result;
}

document.write(fetch());â€‹ //will print snap always, actual result has not yet arrived


 -0 Realistic Callback Usage
---------------------------------

function fetch(receiver) {
    $.getJSON("blah...", function(data) { //inside 1st cb
        receiver(data); //invoke second cb
    });
}

fetch(function(result) { document.write(result); });

 -0 Cleaner Callbacks - Generator
----------------------------------
  > Generators can be used to make asynchronous code a lot more linear in style.
  > Not standardized till JavaScript 1.7

 -0 No Callbacks - I
-----------------------
  > JavaScript 1.7 - Firefox introduces yield
  > yield can be used for implementing generators & coroutines
  > coroutines can be used to implement event loops as an alternative to callback


 -0 Coroutine Example
---------------------------
function test() {
    console.log('Hello!');
    var x = yield;
    console.log('First I got: ' + x);
    var y = yield;
    console.log('Then I got: ' + y);
}

var tester = test();
tester.send(); // prints 'Hello!'
tester.send('a cat'); // prints 'First I got: a cat'
tester.send('a dog'); // prints 'Then I got: a dog'

 -0 Coroutine Wrapper function
---------------------------------
function coroutine(f) {
    var o = f(); // instantiate the coroutine
    o.send(); // execute until the first yield
    return function(x) {
        o.send(x);
    }
}

var test = coroutine(function() {
    console.log('Hello!');
    var x = yield;
    console.log('First I got: ' + x);
    var y = yield;
    console.log('Then I got: ' + y);
});
// prints 'Hello!'

test('a dog'); // prints 'First I got: a dog'
test('a cat'); // prints 'Then I got: a cat'


 -0 Coroutine that never ends
----------------------------------
var clock = coroutine(function() {
    while (true) {
        yield;
        console.log('Tick!');
        yield;
        console.log('Tock!');
    }
});

clock(); // prints 'Tick!'
clock(); // prints 'Tock!'
clock(); // prints 'Tick!'

setInterval(clock, 1000); //Tick Tock every 1 second


 -0 CoRoutine Event loop
-------------------------
  > use coroutines as callbacks for event
  > the event object will be sent to the running coroutine
  > this will be a form of infinite loop

var loop = coroutine(function() {
    var event;
    while (event = yield) { // wait for a mousedown
        if (event.type == 'mousedown') {
            while (event = yield) { // process mousemoves until a mouseup
                if (event.type == 'mousemove') move(event);
                if (event.type == 'mouseup') break;
            }
        }
    }
});

$('#box').mousedown(loop);
$(window).mousemove(loop)
  .mouseup(loop);

 -0 CoRoutine as State Machine
---------------------------------
  > corotuine never explicitly stores any state
  > coroutine add a new form of state to the language, namely the state where the coroutine is currently suspended
  > this implicit coroutine state => consistency is guaranteed
















References -
http://bjouhier.wordpress.com/
http://stackoverflow.com/questions/2222847/asynchronous-programming-in-javascript-without-messy-callbacks
http://syzygy.st/javascript-coroutines/
