

 C Structs
---------------
  > includes pad bytes to maintain alignment for C types involved
  > C Types represented in machine's native format & byte order
  
  C Type  Byte Order
-------------
  > can be native / little-endian / big-endian / network (=big-endian)
  > depends on host system


  C Type Size
--------------
  > can be native or standard

  C Type Alignment
------------------
  > can be native / none


  JSON Stringify
------------------
  > When you prepare for a transmit the data is JSON Stringified

  JSON Parse
-----------------
  > When you accept a transmitted data you parse the data

   Receive Data + NODE JS Snippet
--------------------------------
  > JSON.parse the data
  > if data is base64 encoded then decode 
  > raw = new Buffer(base64decoded, 'binary')
  > socket.write(raw)
 

 Python Struct
--------------
  > provides conversion between Python values & C structs
  > C structs represented as Python strings

  Handle binary data
--------------------------
  > can be stored in files
  > can be transferred in network
  > Python struct module can be used to handle binary data




 
  I/O Channel
-------------------------------
  >> I/O Channels = streams
  >> stdio : 0, stdout = 1, stderr = 2
  
  PIPE
-------------
  > allows stdout from 1 program to be fed as stdio of another program
  > no need for temporary file


 -0 XMLStreamWriter -
-----------------------
  > enable writing of XML programmatically
  > check if proper escaping is enabled/disabled
  > i.e. < > etc special chars should be in place inside the XML

 -0 Write events to DISK
----------------------------
  > use XMLStreamWriter
  > use FileWriter to open up a file on disk

 -0 Write XML to System.out
-----------------------------
  > use XMLStreamWriter
  > use System.out

 -0 Convert XML from library A's type into library B's type
-------------------------------------------------
  > serialize library A's object into outputstream via XMLStreamWriter
  > feed a inputstream from above output stream
  > create library B's object from inputstream via some parser library

 -0 org.w3c.dom.Document + Generate
------------------------------------
  > use javax.xml.parsers.DocumentBuilder
  > parse the inputstream using DocumentBuilder


 -0 Serialize java object to OutputStream
--------------------------------------------
  > serialize to ByteArrayOutputStream
  > serialize may be implemented by the java object
  > e.g. serialize using XMLStreamWriter
  > > more formatting via decorators etc
  
 -0 Write a Document to XXX
------------------------------
  > write a org.w3c.dom.Document to String/file/writer/stream
  > write to stream via StreamResult & java.io.ByteArrayOutputStream & ToXMLStream & DOMSource
  > write to file via StreamResult & java.io.FileWriter & ToXMLStream & DOMSource
  > write to Writer via StreamResult & java.io.Writer & ToXMLStream & DOMSource
  > StreamResult = javax.xml.transform.stream.StreamResult
  > ToXMLStream  = org.apache.xml.serializer.ToXMLStream
  > DOMSource    = javax.xml.transform.dom.DOMSource



-0 What is Messaging
--------------------------
  > producers  +  broker +  consumers
  > can be without a broker - ref ZeroMQ

 -0 ZeroMQ Compared With
--------------------------
  > SCTP + JGroups = make arbitrary networks using 'brokerless' peers
  > SCTP - Messaging
  > JGroups - pub sub
 
 -0 Why SCTP - Stream Control Transmission Protocol
--------------
  -0 Limitations of TCP
-------------------------
  > strict order of transmission delivery of data
  > head-of-line blocking offered by TCP causes unnecessary delay
  > Applications must add their own record marking to delineate their messages, 
  >> and must make explicit use of the push facility to ensure that a complete message is transferred.
  > The limited scope of TCP sockets complicates the task of providing highly-available data transfer 
  >> capability using multi-homed hosts.
  > TCP is relatively vulnerable to denial-of-service attacks, such as SYN attacks.

  -0 Features woth SCTP
--------------------------
  > multi-homing support on both ends
  >> multi-homing = consist of more than one IP address
  >> enabling transparent failover between redundant network paths
  > multi stream - delivery of chunks with independent streams
  > validation & acknowledgement mechanisms protect against flooding attacks
  > provide notification of duplicated or missing data chunks
  > simpler packet structure than TCP
  > Security - 4 way handshake to protect against SYN flooding
  >> protect against large cookies for association verification & authenticity
  > Not supported directly in Windows





 -0 Kafka
------------------------
  > high throughpur
  > persistent
  > pub-sub
  > messaging

 -0 Kafka - Recipes
--------------------------
  > tracking
  > requests per second


 -0 Recipe - kafaesque
-------------------------
  > multiple workers (push)
  > single Q
  > multiple fetchers (pull)

 -0 RabbitMQ
------------------
  > implements AQMP
  > implements broker architecture
  > advanced scenarios like routing, load balancing, or persistent message queuing
  > less scalable & slower because the central node adds latency & messages envelopes are quite big
  > an Enterprise Message Queue ..
  >> persistence
  >> support for transactions
  > focusses on how messages r stored, filtered & monitored & failover


 -0 ZeroMQ
---------------
  > lightweight message oriented socket implementation
  > high throughput low latency
  > mostly DIY
  > acts as concurrency framework
  > faster than TCP, for clustered products
  > carries messages across inproc, IPC, TCP, & multicast
  >> i.e. suitable for in process asynchronous programming
  >> mostly a message oriented IPC library
  > Connect N-to-N via fanout, pubsub, pipeline, request reply
  > Async IO for scalable multicore message passing apps
  > focusses on how messages r transferred over the wire
  > 




 -0 ActiveMQ
-----------------
  > can be with broker or P2P topology
  > like RabbitMQ, easier to implement advanced scenarios but @ the cost of raw performance
















