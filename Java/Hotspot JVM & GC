 - Set Targets for Collectors -
 ------------------------------
 - GC Time Ratio
 - Max GC Pause Millis
 - Max HeapSize

 - â€‘XX:GCTimeRatio=99 -
 --------------------------
 - amount of work done vs time spent in GC
 
 - -XX:MaxGCPauseMillis -
 ------------------------------
 - Latency 
 - time taken by systems in responding to events which is impacted by pauses due to GC
 
 
 - Q - Does Hotspot achieve above targets ?
 
 - record life of object -
 ------------------------------
 - hotspot collector record via no of GC cycles survived
 
 - Frequent Minor Collections -
 --------------------------------
 - short lived objs r collected
 
 - Less Often Major Collections -
 ---------------------------------
 - older regions r collected
 
 - HotSpot VM Heap Flows -
 -----------------------------
 
 -------------------------------------
   Eden | From Survivor | To Survivor
 -------------------------------------
   Eden -----> To Survivor
   From Survivor <-----> To Survivor
   To Survivor -----> Old Gen
   
   
 - Frequency of Minor GC -
 ---------------------------
 - depends on obj allocation rate
 - size of eden space
 
 - Freqency of Obj promotion into Old Gen -
 -------------------------------------------
 - depends on freq of Minor GC
 - Size of survivor spaceS
 
  
 - Object Retention vs. Object Allocation -
 ----------------------------------------------
 - retention can degrade performance more than allocation
 
 - Object Allocation -
 --------------------------
 - is cheap ... max 10 CPU instructions
 
 - Reclaim new objects -
 --------------------------
 - is cheap as GC visits only ___ 
 
 - GC loves 2 girls -
 --------------------
 - small immutable objects
 - short lived objects
 
 - GC loves -
 -----------------
 - objs that get killed in Minor GC
 
 - Tuning - Rule of Thumb - 
 --------------------
 - Stop promotions
 - - objs should die often
 - - Space of survivor should be good enough
 
 - GC Visits -
 -------------------
 - only live objects
 
 - GC Duration -
 --------------------
 - func of no of live objects & object graph complexity
 
 - Thumb Rule - can go wrong -
 --------------------------------
 - if needless allocations
 - leading 2 frequent Minor GCs
 - leading to faster obj aging
 - leading to faster promotions
 - leading to frequent Old GC collection
 
 - Choosing a GC -
 ---------------------
 - start with Parallel GC
 - idea here is to avoid full GC altogether if we can
 
 
 - Parallel GC -
 --------------------
 - offers fastest minor GC times
 
 - Cannot Avoid Old Gen Collections -
 --------------------------- 
 - Try CMS or G1
 
 - CMS -
 -----------
 - use if app experiences old gen collections
 - avoids Full GC via old gen concurrent collection
 
 - G1 -
 ----------
 - use if app experiences old gen collections
 - avoids Full GC via concurrent collection
 - avoids fragmentation via partial old gen collection
 
 - CMS & Minor GC -
 --------------------
 - slower due 2 promotion into free lists
 
 - G1 & Minor GC -
 ---------------------
 - slower due to remembered set
 
 
 - GC Friendly Programming -
 ----------------------------
 - avoid large objects
 - avoid re-sizing of array based collections
 - Object pooling has issues with GC coz former is live objects
 - Dont use Finalizers coz it takes 2 GC cycles
 - - free resources explicitly - JDK's DirectByteBuffer implementation
 - Dont use SoftReferences
 - Inner Classes - can increase object retention
 
 - Minor GC Pause Time - 
 --------------------------
 - mostly due to #live objs
 - also ref objects, object graph structure, no of promotions to old gen
 
 - Full GC Frequency -
 -------------------------
 - dictated by promotion rate, size of old gen
 
 - Safepoint -
 ------------------
 - GC signals ALL the RUNNING threads to stop at a safepoint
 
 - Safepoint & Heap -
 -----------------------
 - Heap of the app will be consistent when all threads reach their safepoint
 
 - Time taken to Safepoint -
 --------------------------------
 - less the better for low latency apps
 - -XX:+PrintGCApplicationStoppedTime
 
 - Tenured Space -
 ---------------------
 - is the Old Gen
 
 - Young Gen -
 ----------------
 - Eden & Survivor space
 
 - TLAB -
 --------------
 - Each thread is assiged a Thread Local Allocation Buffer
 
 - When TLAB is Exhausted ? -
 ---------------------------------- 
 - Thread requests a new one from Eden.
 - When Eden has been filled a minor collection commences
 
 - Promotion or Tenuring -
 -------------------------------
 - happens when objs r old -XX:MaxTenuringThreshold
 - or when Survivor space overflows
 
 - Minor Collection vs Eden Size -
 ------------------------------------
 - Not related
 
 - Minor Collection vs # of live objs -
 -------------------------------------------
 - directly proportional
 
 - Minor Collection vs # of Old objs -
 -----------------------------------------
 - proportional due to cross-generational reference objs
 
 - to-space vs from-space -
 -----------------------------
 - are survivor spaces
 - alternate their roles
 
 - to-space -
 ------------------
 - is the target area where live objs from Eden & from-space r copied
 
 - from-space -
 ------------------
 - is the previous minor collection's target survivor space
 
 -----------------------------------------------------------------------------------------
 # Hence, if Eden Size is doubled then time taken for minor collection is halved         #
 # Memory traded for throughput                                                          #
 # Increase in collection time, but its OK if # objs promoted & old gen size is constant #
 -----------------------------------------------------------------------------------------
 
 - STW Events -
 ---------------
 - In hotspot Minor Collections are Stop The World events.
 - Hence, concurrent collection in young gen is required
 
 
 
 
 
 
 Reference 
 - http://www.infoq.com/presentations/jvm-tuning
 - http://www.infoq.com/articles/Java_Garbage_Collection_Distilled?utm_source=infoq&utm_medium=popular_links_homepage
 - 
 
 
 
 
