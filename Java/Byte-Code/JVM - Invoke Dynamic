 Read More 
 --------------
 - http://arxiv.org/pdf/1210.1039.pdf
 - http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html
 - http://jaxenter.com/404
 - http://www.ec-spride.tu-darmstadt.de/media/ec_spride/secure_software_engineering/theses_1/kamil_erhard_master_thesis.pdf
 - http://www.bodden.de/pubs/bodden12invokedynamic.pdf
 - 


 Lamdba Expressions
------------------------
  > static & dynamic expressions
  > defer the selection of translation strategy intil runtime
  
  Desugar
----------
  > Desugar the lambda body into a method

  Desugar 2 what ?
---------------
  > static method or instance method ?
  > in what class should this desugared methd go ?
  > etc ?


  Indy OpCode <-LINK-> Bootstrap Method
------------------------------------------
  > Opcode is linked to bootstrap method via a Method Handle
  
  MethodHandle <-> CallSite
  ---------------------------------
  > the Method Handle matches the call site  

  MethodHandle vs Reflection Method
-------------------------------------
  > Method Handles are type-checked only at creation time
  > Reflection objects need to perform checking for each invocation
  
  Method Handle combinators 
 ------------------------------
  > found in java.lang.invoke.MethodHandle
  > > filterArguments
  > > filterReturnValue
  > Keeps the method handle chain almost intact, it protects JIT optimizations

 InvokeBinder
 -------------
 - MethodHandle made easy
 
 MethodHandle & Security Checks
 ----------------------------------
 - done during creation
 - they r immutable
 
 Reflection vs MethodHandles
 --------------------------
 - Security Checks done at each call . Hence, reflection is slow
 
 MethodHandle && Code Snippet
 ------------------------------
 MethodHandle honk = MethodHandles.lookup()
                                  .findVuirtual(Car.class, "honk", MethodType.methodType(void.class));
 honk.invoke(new Car());
 
 
 
 
 
 
 
 
 




References
---------------
1/ http://arxiv.org/pdf/1210.1039.pdf
2/ 
