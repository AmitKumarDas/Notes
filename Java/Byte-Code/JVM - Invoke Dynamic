 Read More 
 --------------
 - http://arxiv.org/pdf/1210.1039.pdf
 - http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html
 - http://jaxenter.com/404
 - http://www.ec-spride.tu-darmstadt.de/media/ec_spride/secure_software_engineering/theses_1/kamil_erhard_master_thesis.pdf
 - http://www.bodden.de/pubs/bodden12invokedynamic.pdf
 
 - A new form -
 ------------------
 - of invocation
 
 - usage -
 ----------------
 - dynamic usage & others
 
 - Argument manipulation -
 -----------------------------
 - MethodHandles
 
 - Bootstrap -
 ------------------
 - prepares CallSite & MethodHandle
 
 - Tools -
 ----------
 - object web's ASM lib
 - Jitescript - DSL wrapper around ASM
 - InvokeBinder - DSL API for building MH chanins
 
 - Select call target @ runtime. Why ? -
 ------------------------------------
 - not enough linkage info @ compile time
 
 - MethodHandle -
 ---------------------
 - a successful lookup - a object pointing to field/method/constructor impl
 
 - MethodHandle & .invoke()
 ------------------------------
 - similar 2 Reflection's Method's .invoke() ~ arbitary no of args
 
 - Adaptation -
 ---------------
 - adaptation methods are provided in MethodHandle & MethodHandles classes
 
 
 - 
 
 

 Usage --> Lamdba Expressions
------------------------
  > static & dynamic expressions
  > defer the selection of translation strategy intil runtime
  
  Desugar
----------
  > Desugar the lambda body into a method

  Desugar 2 what ?
---------------
  > static method or instance method ?
  > in what class should this desugared methd go ?
  > etc ?


  Indy OpCode <-LINK-> Bootstrap Method
------------------------------------------
  > Opcode is linked to bootstrap method via a Method Handle
  
  MethodHandle <-> CallSite
  ---------------------------------
  > the Method Handle matches the call site  

  MethodHandle vs Reflection Method
-------------------------------------
  > Method Handles are type-checked only at creation time
  > However, Reflection objects need to perform checking for each invocation
  
  Method Handle combinators 
 ------------------------------
  > found in java.lang.invoke.MethodHandle
  > > filterArguments
  > > filterReturnValue
  > Keeps the method handle chain almost intact, it protects JIT optimizations

 InvokeBinder
 -------------
 - MethodHandle made easy
 
 MethodHandle & Security Checks
 ----------------------------------
 - done during creation
 - they r immutable
 
 Reflection vs MethodHandles
 --------------------------
 - Security Checks done at each call . Hence, reflection is slow
 
 MethodHandle && Code Snippet
 ------------------------------
 MethodHandle honk = MethodHandles.lookup()
                                  .findVirtual(Car.class, "honk", MethodType.methodType(void.class));
 honk.invoke(new Car());
 
 
 
 
 
 
 
 
 




References
---------------
1/ http://arxiv.org/pdf/1210.1039.pdf
2/ 
