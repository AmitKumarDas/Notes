  Its such a big topic ... need to learn this !!



Example
--------------
  2010-04-16T12:11:18.979+0200: 84.335: 
        [GC 84.336: [ParNew: 273152K->858K(341376K), 0.0030008 secs] 
                    273152K->858K(980352K), 0.0031183 secs] 
        [Times: user=0.00 sys=0.00, real=0.00 secs]


  > 84.35 ~ timestamp ~ no of seconds after JVM startup
  > 2010-04-16T12:11:18.979+0200: ~ datestamp ~ enabled via -XX:+PrintGCDateStamps


  Settings
----------------
CMS GC with -XX:+PrintGCDetails and -XX:+PrintGCTimeStamps prints a lot of information. 

  Collectors
------------
  > Concurrent Collector  - GC with app execution
  > parallel Collector - uses multiple CPUs for GC
  > Stop The World Collector - performs GC while app is stopped completely
  > Incremental Collector - performs GC as a series of small ops with longer gaps in between
  
   GC Safepoint
---------------------------
  > point where the collector can identify all the references in that thread's execution stack


   Oldgen & CMS
-------------------------
  > Mark Sweep Compact - common for OldGen

  YoungGen & CC
---------------------
  > Copying Collector - common for YoungGen

  Mark
-----------
  > all reachable objs marked live
  > all NON reachable objs marked DEAD

  Sweep
-----------
  > Scan the heap
  > Identify DEAD objects
  
  Compact
------------
  > Defragments the heap

  Compact
-----------------
  > Move LIVE objects together to reclaim CONTIGUOUS empty space
  > above is Relocate
  > obj references need to be corrected to these new locations - remap
  > Remap scan

  Copy
-----------
  > moves all lives objects
  
 OOME
-----------
  > There is little that you can do about it, except to exit the program, change the -Xmx value, and restart the JVM.
  > Is -Xmx is too large, you slow down the application
  > Out Of Memory Exception can happen in any thread
  > This thread dies

  OOME & its Stack Trace
---------------------------
  > often there is not enough memory to build the stack trace for the OOME


  








  
  
