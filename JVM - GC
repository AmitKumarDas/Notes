  Its such a big topic ... need to learn this !!



Example
--------------
  2010-04-16T12:11:18.979+0200: 84.335: 
        [GC 84.336: [ParNew: 273152K->858K(341376K), 0.0030008 secs] 
                    273152K->858K(980352K), 0.0031183 secs] 
        [Times: user=0.00 sys=0.00, real=0.00 secs]


  > 84.35 ~ timestamp ~ no of seconds after JVM startup
  > 2010-04-16T12:11:18.979+0200: ~ datestamp ~ enabled via -XX:+PrintGCDateStamps


  Settings
----------------
CMS GC with -XX:+PrintGCDetails and -XX:+PrintGCTimeStamps prints a lot of information. 

  Collectors
------------
  > Concurrent Collector  - GC with app execution
  > parallel Collector - uses multiple CPUs for GC
  > Stop The World Collector - performs GC while app is stopped completely
  > Incremental Collector - performs GC as a series of small ops with longer gaps in between
  
   GC Safepoint
---------------------------
  > point where the collector can identify all the references in that thread's execution stack


   Oldgen & CMS
-------------------------
  > Mark Sweep Compact - common for OldGen

  YoungGen & CC
---------------------
  > Copying Collector - common for YoungGen

  Mark
-----------
  > all reachable objs marked live
  > all NON reachable objs marked DEAD

  Sweep
-----------
  > Scan the heap
  > Identify DEAD objects
  
  Compact
------------
  > Defragments the heap

  Compact
-----------------
  > Move LIVE objects together to reclaim CONTIGUOUS empty space
  > above is Relocate
  > obj references need to be corrected to these new locations - remap
  > Remap scan

  Copy
-----------
  > moves all lives objects
  
 OOME
-----------
  > There is little that you can do about it, except to exit the program, change the -Xmx value, and restart the JVM.
  > Is -Xmx is too large, you slow down the application
  > Out Of Memory Exception can happen in any thread
  > This thread dies

  OOME & its Stack Trace
---------------------------
  > often there is not enough memory to build the stack trace for the OOME


  Tenured Generation Pool
-----------------------------
  > objs surviving the young generation migrate to tenured
  > -Xmx - the max memory to be used in Tenured Generation

  Young Gen
---------------
  > lots & lots of garbage in it
  > normally a copy collector

  Tenured Gen
-----------------
  > longer lived objs
  > normally mark & sweep collector


  NewRatio
---------------
  > a ratio of 2 means
  > = Tenured Generation Size is 2/3 of Total heap size
  > = Young Generation Size is 1/3 of Total heap size

  Aliter of Newratio
-------------------------
  > NewSize & MaxNewSize refers to Young Gen sizes

  If Young & Tenured Gen is FULL
-----------------------------------
  > lets say young & tenured gen is over flowing with long lived data
  > So, Minor GC cannot be done successfully
  > Hence, a Major GC will be done
  > However, all the next collections will be Major GCs only
  > increasing the NewRatio might help









  








  
  
